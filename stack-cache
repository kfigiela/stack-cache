#!/usr/bin/env stack
-- stack --resolver lts-16.3 script --package yaml --package aeson --package universum --package shelly --package optparse-applicative --package text

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ExtendedDefaultRules #-}
{-# OPTIONS_GHC -fno-warn-type-defaults #-}


import Universum
import Shelly hiding (whenM)
import Options.Applicative hiding (command)
import Options.Applicative.Help ((.$.))
import qualified Options.Applicative as O

import qualified Data.Yaml as Y
import qualified Data.Text as T
default (Text)

main :: IO ()
main =
  execParser (info (opts <**> helper) ( fullDesc
     <> header "stack-cache â€“ manage stack-work cache during SCM branch switches"
     <> footerDoc (Just $ "Make sure to ignore stack-cache directories:" .$. "$ git config --global core.excludesfile ~/.gitignore" .$. "$ echo .stack-work-cache >> ~/.gitignore")
     ))
   >>= shelly

opts :: Parser (Sh ())
opts = subparser
  ( O.command "build"               (info (stackBuild <$> some (argument str (metavar "ARGUMENTS..."))) (progDesc "Alias for stack build, use with --"))
 <> O.command "switch"              (info ((gitSwitch . Branch) <$> argument str idm) (progDesc "Alias for git switch"))
 )
 <|> subparser
 (  O.command "init"                (info (pure initCache) (progDesc "Create initial directory structure"))
 <> O.command "restore"             (info (pure restore) (progDesc "Restore stack-work from current branch cache"))
 <> O.command "store"               (info (pure store) (progDesc "Store stack-work to per-branch cache"))
 <> O.command "restoreFrom"         (info ((restoreFrom .  Branch) <$> argument str (metavar "BRANCH")) (progDesc "Restore stack-work from specified branch cache"))
 <> O.command "cleanup"             (info ((cleanupBranch . Branch) <$> argument str (metavar "BRANCH")) (progDesc "Delete sepecified branch cache"))
 <> O.command "cleanup-current"     (info (pure cleanupCurrent) (progDesc "Remove current stack-work"))
 <> commandGroup "Maintenance & setup"
 <> hidden
 )


store :: Sh ()
store = do
  currentBranch <- silently $ Branch <$> git "rev-parse" "--abbrev-ref" "HEAD"
  initCache
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "rm" "-rf" (cacheDir currentBranch)
    whenM (test_d $ toString currentWorkdir) $ cmd "cp" "-cpr" currentWorkdir (cacheDir currentBranch)

restore :: Sh ()
restore = do
  currentBranch <- silently $ Branch <$> git "rev-parse" "--abbrev-ref" "HEAD"
  restoreFrom currentBranch

restoreFrom :: Branch -> Sh ()
restoreFrom fromBranch = do
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "rm" "-rf" currentWorkdir
    whenM (test_d $ toString (cacheDir fromBranch)) $ cmd "cp" "-cpr" (cacheDir fromBranch) currentWorkdir
    cmd "tmutil" "addexclusion" ".stack-work"

initCache :: Sh ()
initCache = do
  forAllPackages $ \package -> sub $ do
    cd package
    mkdir_p "./.stack-work-cache/branch"
    mkdir_p "./.stack-work"
    cmd "tmutil" "addexclusion" ".stack-work"
    cmd "tmutil" "addexclusion" ".stack-work-cache"

cleanupBranch :: Branch -> Sh ()
cleanupBranch branch = do
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "rm" "-rf" (cacheDir branch)

cleanupCurrent :: Sh ()
cleanupCurrent = do
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "rm" "-rf" currentWorkdir

stackBuild :: [Text] -> Sh ()
stackBuild args = verbosely $ do
  currentBranch <- silently $ Branch <$> git "rev-parse" "--abbrev-ref" "HEAD"
  run_ "/usr/bin/env" $ ["stack", "build", "--color", "always"] <> args


gitSwitch :: Branch -> Sh ()
gitSwitch newBranch = do
  putTextLn "Storing current branch cache"
  store
  putTextLn $ "Switching branch to " <> unBranch newBranch
  cmd "git" "switch" $ unBranch newBranch
  isCached <- test_d $ toString $ cacheDir newBranch
  if isCached
    then do
      putTextLn $ "Stack cache found, restoring..."
      restore
    else do
      putTextLn $ "Stack cache not found, restoring from master..."
      restoreFrom (Branch "master")



data StackYAML = StackYAML { packages :: [FilePath] } deriving (Generic, Y.FromJSON)

newtype Branch = Branch { unBranch :: Text }

sanitizeBranch :: Branch -> Text
sanitizeBranch (Branch branch) = T.strip $ T.replace "/" "_" branch

cacheDir :: Branch -> Text
cacheDir branch = "./.stack-work-cache/branch/" <> sanitizeBranch branch

currentWorkdir :: Text
currentWorkdir = "./.stack-work"

git = cmd "/usr/bin/git"

allPackages :: MonadIO m => m [FilePath]
allPackages = packages <$> liftIO (Y.decodeFileThrow "stack.yaml")

forAllPackages :: MonadIO m => (FilePath -> m ()) -> m ()
forAllPackages action = do
  packages <- allPackages
  forM_ packages $ \package -> action package >> putText "."
  putText "\n"
