#!/usr/bin/env stack
-- stack --resolver lts-16.3 script --package yaml --package aeson --package universum --package shelly --package optparse-applicative --package text

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ExtendedDefaultRules #-}
{-# OPTIONS_GHC -fno-warn-type-defaults #-}


import Universum
import Shelly hiding (whenM, unlessM)
import Options.Applicative hiding (command)
import Options.Applicative.Help ((.$.))
import qualified Options.Applicative as O

import qualified Data.Yaml as Y
import qualified Data.Text as T
default (Text)

main :: IO ()
main =
  execParser (info (opts <**> helper) ( fullDesc
     <> header "stack-cache â€“ manage stack-work cache during SCM branch switches"
     <> footerDoc (Just $ "Make sure to ignore stack-cache directories:" .$. "$ git config --global core.excludesfile ~/.gitignore" .$. "$ echo .stack-work-cache >> ~/.gitignore")
     ))
   >>= shelly

opts :: Parser (Sh ())
opts = subparser
 (  O.command "init"                (info (pure initCache) (progDesc "Create initial directory structure"))
 <> O.command "relink"              (info (pure relink) (progDesc "Relink stack-work from current branch cache"))
 <> O.command "clone"               (info ((clone . Branch) <$> argument str (metavar "BRANCH")) (progDesc "Clone stack-work from other branch cache"))
 <> O.command "clean-branch"        (info ((cleanupBranch . Branch) <$> argument str (metavar "BRANCH")) (progDesc "Delete sepecified branch cache"))
 <> O.command "clean"               (info (pure $ getCurrentBranch >>= cleanupBranch) (progDesc "Remove current stack-work, use relink to copy from master"))
 )


relink :: Sh ()
relink = do
  currentBranch <- getCurrentBranch
  forAllPackages $ \package -> sub $ do
    cd package
    whenM (test_e $ toString stackWork) $ cmd "rm" stackWork
    cacheExists <- test_d $ toString (cacheDir currentBranch)
    masterExists <- test_d $ toString $ cacheDir (Branch "master")
    unless cacheExists $ do
      if masterExists
        then do
          putText "C"
          cmd "cp" "-cpr" (cacheDir (Branch "master")) (cacheDir currentBranch)
        else do
          mkdir_p $ toString $ cacheDir currentBranch
    cmd "ln" "-s" (cacheDir currentBranch) stackWork

clone :: Branch -> Sh ()
clone fromBranch = do
  currentBranch <- getCurrentBranch
  cleanupBranch currentBranch

  forAllPackages $ \package -> sub $ do
    cd package
    cmd "cp" "-cpr" (cacheDir fromBranch) (cacheDir currentBranch)

initCache :: Sh ()
initCache = do
  currentBranch <- getCurrentBranch
  forAllPackages $ \package -> sub $ do
    cd package
    mkdir_p "./.stack-work-cache/branch"
    whenM (test_d $ ".stack-work") $
      unlessM (test_d $ toString $ cacheDir currentBranch) $
        cmd "mv" ".stack-work" $ cacheDir currentBranch
    cmd "rm" "-rf" ".stack-work"
  relink
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "tmutil" "addexclusion" ".stack-work-cache"
    cmd "tmutil" "addexclusion" ".stack-work"


cleanupBranch :: Branch -> Sh ()
cleanupBranch branch = do
  forAllPackages $ \package -> sub $ do
    cd package
    cmd "rm" "-rf" (cacheDir branch)

data StackYAML = StackYAML { packages :: [FilePath] } deriving (Generic, Y.FromJSON)

newtype Branch = Branch { unBranch :: Text }

sanitizeBranch :: Branch -> Text
sanitizeBranch (Branch branch) = T.strip $ T.replace "/" "_" branch

cacheDir :: Branch -> Text
cacheDir branch = "./.stack-work-cache/branch/" <> sanitizeBranch branch

stackWork :: Text
stackWork = "./.stack-work"

git = cmd "/usr/bin/git"

allPackages :: MonadIO m => m [FilePath]
allPackages = packages <$> liftIO (Y.decodeFileThrow "stack.yaml")

forAllPackages :: MonadIO m => (FilePath -> m ()) -> m ()
forAllPackages action = do
  packages <- allPackages
  forM_ packages $ \package -> action package >> putText "."
  putText "\n"

getCurrentBranch :: Sh Branch
getCurrentBranch = silently $ Branch <$> git "rev-parse" "--abbrev-ref" "HEAD"
